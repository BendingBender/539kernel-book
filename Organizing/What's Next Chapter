Normal Stuff: Virtual Memory, Userspace

What are Scientific Papers and How to Find Them

It's not necessary to write a kernel from scratch to implement these ideas. A ready kernel can be used and there are a bunch of them other than Linux. An example is HelenOS which is a microkernel. Google Fuchsia uses Zircon kernel to implements its ideas and of course there are many other examples that we can mention.

=========

Needed Concepts (General, that is, any concepts that are shared by multiple papers):
	* Kernel Architecture: Monolithic and Microkernel.
		* What if 539kernel was a microkernel (simple example from process management).
	* SMP.
	* System Calls.
	
=========

Papers:

#1
Lord of the x86 Rings: A Portable User Mode Privilege Separation Architecture on x86

Authors: Hojoon Lee, Chihyun Song and Brent Byunghoon Kang

Problem:
	In userspace, there is no _privilege separation_ in a running process. So, the whole code of a process is able to read or modify anything that belong to process' memory. There is no distinction between a normal, not important string like "Hello World" and the sensitive information such as passwords and cryptographic keys. When an attacker gains the control of a process, she will be able to read anything without restrictions even if the part of the program that caused the security vulnerability is not related to the sensitive information.

Needed Concepts:
	* ABI
	* Privilege Separation
	* TLB Flushes (?)
	* x86 Callgate (Did we mention it?)
	* How System Calls in Linux work since the implementation in the paper using same methodology to implement "privcall".

Real-world Problem:
	* HeartBleed Vulnerability.
	
Proposed Solution:
	* Overview: Named LOTRx86, it aims to provide a _portable(?)_ privilege separation in user space. A new region called "PrivUser" is introduced in every process which is inaccessable in user-mode, instead, x86 other privilege levels are used for this region. So, it can keep secrets and no direct user-mode access can be issued to this region without some interface called "privcall", also, it keeps sensitive application code, the code which represents "privcall" interface are also stored in PrivUser, so, this region contains both sensitive data and the routines that access these data. PrivUser is protected from the normal user mode (this property is called M-SR1 in the paper), which most of the application's code run on, also, the kernel is protected from PrivUser mode (this property is called M-SR2 in the paper). So, with this design there will be three modes, kernel-mode, use-mode and PrivUser mode.
	* In x86 paging, a page previlege can be either (U)ser page or (S)uper page and there is no other distinction which means PrivUser region cannot be realized by only using what x86 paging provides.
	
Notes:
	* Quote: "The LOTRx86 architecture design leverages the x86 privilege structures in a unique way."
		* We can see here an example of kernelist's job. By using an already exists feature in the processor that is usually used in another ways, the authors have build a unique and new solution for a real-world problem.
		
------------

#2:
Nested Kernel: An Operating System Architecture for Intra-Kernel Privilege Separation

Authors: Nathan Dautenhahn, Theodoros Kasampalis, Will Dietz, John Criswell and Vikram Adve

Published: 2015

Suggested Subsection Title:
	* Single Point of Exploitation.
	
Needed Concepts:
	* Trusted Computing Base (TCB).
	* Security Design Principles?: Fail-safe defaults, complete mediation, least privilege and least common mechanism. (Maybe OpenBSD can be used as example).
	* Kernel Call Hooking
	
Problem:
	* Monolithic kernels are large trusted computing base. Any exploitable part in it (e.g. buggy device drivers) causes the ability to do anything with the kernel which means that the attacker is able to do whatever he wants on the system. Monolithic kernels store everything in one address spaces which is reachable by all kernel's components, for example, the code of access control policies, that means the attacker can modify them once the kernel is compromized, also, this design doesn't help in implementing protection design principles shuch as least privilege and so on. One solution is using microkernel design but it needs extensive redesign and implementation of the operating system.
	
Proposed Solution:
	*
	* Both trusted (nested kernel) and untrusted (outer kernel) code (components) of the kernel run on kernel-mode.
